# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса
# (метод __init__()), который должен принимать данные (список списков) для
# формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в
# виде прямоугольной схемы.Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в
# привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения
# двух объектов класса Matrix (двух матриц). Результатом сложения должна быть
# новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент
# первой строки первой матрицы складываем с первым элементом первой строки второй
# матрицы и т.д.
import copy


class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix

    def __str__(self):
        return '\n'.join('\t'.join(map(str, row)) for row in self.matrix)

    def __add__(self, other):
        res = copy.deepcopy(self.matrix)
        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[0])):
                res[i][j] = self.matrix[i][j] + other.matrix[i][j]
        return Matrix(res)


m1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
m2 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(f'New matrix 3x3:\n{m1 + m2}')
m3 = Matrix([[1, 2, 3], [4, 5, 6]])
m4 = Matrix([[1, 2, 3], [4, 5, 6]])
print(f'New matrix 3x2:\n{m3 + m4}')
m5 = Matrix([[1, 2],  [3, 4], [5, 6], [7, 8]])
m6 = Matrix([[1, 2],  [3, 4], [5, 6], [7, 8]])
print(f'New matrix 2x4:\n{m5 + m6}')
#
# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь
# определенное название. К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для
# пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3). Проверить работу этих методов
# на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом
# уроке знания: реализовать абстрактные классы для основных классов проекта,
# проверить на практике работу декоратора @property.


class Clothes:
    def __init__(self, size, height):
        self.size = size
        self.height = height

    def calc_expense(self, size, height):
        return


class Coat(Clothes):
    def __init__(self, size, height):
        super().__init__(size, height)

    @property
    def calc_expense(self):
        return round(self.size / 6.5 + 0.5, 2)


class Suit(Clothes):
    def __init__(self, size, height):
        super().__init__(size, height)

    @property
    def calc_expense(self):
        return round(2 * self.height + 0.3, 2)


coat = Coat(46, 1)
suit = Suit(1, 175)
print(f'Expense for all clothes: {coat.calc_expense + suit.calc_expense}')
#
# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс
# Клетка. В его конструкторе инициализировать параметр, соответствующий количеству
# клеток (целое число). В классе должны быть реализованы методы перегрузки
# арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение
# (__mul__()), деление (__truediv__()).Данные методы должны применяться только к
# клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное)
# деление клеток, соответственно. В методе деления должно осуществляться округление
# значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться
# сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется
# как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется
# как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса
# и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек
# между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает,
# то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда
# метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.
# https://pythonworld.ru/osnovy/peregruzka-operatorov.html


class Cell:
    def __init__(self, quantity):
        self.quantity: int = quantity

    def __str__(self):
        return f'{self.quantity}'

    def __add__(self, other):
        return Cell(self.quantity + other.quantity)

    def __sub__(self, other):
        if self.quantity >= other.quantity:
            return Cell(self.quantity - other.quantity)
        else:
            print('Negative result')

    def __mul__(self, other):
        return Cell(self.quantity * other.quantity)

    def __truediv__(self, other):
        return Cell(self.quantity // other.quantity)

    def make_order(self, cells_num):
        result = ''
        for i in range(int(self.quantity / cells_num)):
            result += f'{"*" * cells_num} \\n'
        result += f'{"*" * (self.quantity % cells_num)}'
        return result


c_1 = Cell(27)
c_2 = Cell(8)

print(f'add {c_1 + c_2}')
print(f'sub {c_1 - c_2}')
print(f'mul {c_1 * c_2}')
print(f'truediv {c_1 / c_2}')
print(c_1.make_order(4))
print(c_2.make_order(3))
